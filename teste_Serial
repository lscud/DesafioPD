#include <EEPROM.h>

//
int recebido = 0;
int led1 = LOW;
int led2 = LOW;
int led3 = LOW;

// Variaveis Globais
boolean flag_menu;
boolean flag_option;

const int BUFFER_SIZE = 100;
char buf[BUFFER_SIZE];

String recebi;
String nome;
String senha;
String tipo;
int posicaobase;

// Funções Auxiliares
void dispmenu();
void readoption();
void changeMenu();
void dispMenu();
void UserRegistration();
void Userlist();
void EventList();
void fport1();
void fport2();

void setup()
{
  Serial.begin(9600);
  pinMode(2, OUTPUT);
  pinMode(3, OUTPUT);
  
  flag_menu = 0x01;
  flag_option = 0x01;
  
}

void loop()
{
  if (flag_menu) 
  {
    dispmenu(); 
    flag_menu = 0x00;
  }
  readoption();
  Serial.println(leString(1));
  Serial.println(leString(2));
  
}

void dispmenu()
{
  Serial.println("Escolha entre as opções abaixo: ");
  delay(1000);
  Serial.println("1 - Cadastro");
  Serial.println("2 - Leitura");
  Serial.println("3 - Eventos");
  Serial.println("4 - Abre Porta 1");
  Serial.println("5 - Abre Porta 2");
  
}

void readoption()
{
  if(Serial.available() > 0) {
     recebido = Serial.read();
    switch (recebido){
      case '1':
         //if(led1 == HIGH) {led1 = LOW;} else {led1 = HIGH;}
      	 //digitalWrite(2, led1);
      	 UserRegistration();
      	 break;
      case '2':
         if(led2 == HIGH) {led2 = LOW;} else {led2 = HIGH;}
      	 digitalWrite(3, led2);
      	 dispmenu();
      	 break;
      default:
      	 Serial.println("Opção inválida");
    }
  }
}

  
void UserRegistration()
{
  Serial.println("Digite seu nome: ");
  delay(5000);
  Serial.println(Serial.available());
  	if(Serial.available() > 0) {
        //int rlen = Serial.readBytesUntil('\n', buf, BUFFER_SIZE);
      	nome = Serial.readString();
      	Serial.println(posicaobase);
      	escreveString(posicaobase, nome);
        //EEPROM.write(1, byte nome);
        //Serial.print("I received: ");
    	//for(int i = 0; i < rlen; i++)
      	//Serial.print(buf[i]);
        Serial.println(leString(posicaobase));
    }
  Serial.println("Digite seu password: ");
  delay(5000);
  Serial.println(Serial.available());
  	if(Serial.available() > 0) {
        //int rlen = Serial.readBytesUntil('\n', buf, BUFFER_SIZE);
      	senha = Serial.readString();
        //EEPROM.write(2, senha);
        //Serial.print("I received: ");
    	//for(int i = 0; i < rlen; i++)
      	//Serial.print(buf[i]);
        Serial.println(senha);
    }
  Serial.println("Este usuário é ADM? S/N");
  delay(5000);
  Serial.println(Serial.available());
  	if(Serial.available() > 0) {
        //int rlen = Serial.readBytesUntil('\n', buf, BUFFER_SIZE);
      	tipo = Serial.readString();
        //EEPROM.write(3, tipo);
        //Serial.print("I received: ");
    	//for(int i = 0; i < rlen; i++)
      	//Serial.print(buf[i]);
        Serial.println(tipo);
    }
      	
  	Serial.println("Cadastro Realizado com sucesso \n");
  	//Serial.println(EEPROM.read(Name));
  	flag_menu = 0x01; 
  	posicaobase++;
  
}

void escreveString(int enderecoBase, String mensagem){ // Salva a string nos endereços de forma sequencial
  if (mensagem.length()>EEPROM.length() || (enderecoBase+mensagem.length()) >EEPROM.length() ){ // verificamos se a string cabe na memória a partir do endereço desejado
    Serial.println ("A sua String não cabe na EEPROM"); // Caso não caiba mensagem de erro é mostrada
  }
  else{ // Caso seja possível armazenar 
    for (int i = 0; i<mensagem.length(); i++){ 
       EEPROM.write(enderecoBase,mensagem[i]); // Escrevemos cada byte da string de forma sequencial na memória
       enderecoBase++; // Deslocamos endereço base em uma posição a cada byte salvo
    }
    EEPROM.write(enderecoBase,'\0'); // Salvamos marcador de fim da string 
  }
}
String leString(int enderecoBase){
  String mensagem="";
  if (enderecoBase>EEPROM.length()){ // Se o endereço base for maior que o espaço de endereçamento da EEPROM retornamos uma string vazia
    return mensagem;
  }
  else { // Caso contrário, lemos byte a byte de cada endereço e montamos uma nova String
    char pos;
    do{
      pos = EEPROM.read(enderecoBase); // Leitura do byte com base na posição atual
      enderecoBase++; // A cada leitura incrementamos a posição a ser lida
      mensagem = mensagem + pos; // Montamos string de saídaa
    }
    while (pos != '\0'); // Fazemos isso até encontrar o marcador de fim de string
  }
  return mensagem; // Retorno da mensagem
}
  
  
